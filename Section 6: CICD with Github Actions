ðŸš€ CI/CD
CI - Continuous Integration, in simpler terms, operates around the build process.
CD - Continuous Delivery, in simpler terms, operates around the deployment process.

Letâ€™s consider a scenario: a team member made changes to the program and now wants it to be reviewed by a peer. Now, letâ€™s say Raviâ€™s code has some security issues. 
If other developers collaborate, it can cause problems for them as well if they work on that repo. The team member, X, needs to build/test his code, and the reviewer also needs to do that, which is a lot of manual effort and takes time.
So, CI/CD came up here from DevOps to solve this problem. Instead of doing these tasks manually, we have CI â€” which uses tools like GitHub Actions, Jenkins â€” that run based on pull request or push events on GitHub.

The CI system:
* Checks out the code (pulls code from the repo)
* Builds the code
* Runs unit testing
* Performs static code analysis (like detecting unused variables, deprecated methods)
* Creates a Docker image
* Scans the image
* Updates Kubernetes manifests with that image
Now the team member is confident in all changes and asks the reviewer to check it, saying CI has passed, which saves time and manual effort, and increases efficiency and quality.
Then comes CD â€” which uses tools like GitOps tools or ArgoCD to deploy the application on top of Kubernetes (K8s). So, CD is the continuous delivery of all your changes.

ðŸ”„ Pull Request
A pull request is when we want your changes to be merged with the main branch and reviewed by a peer. We create a pull request by first creating a branch with your changes. 
Before that, you make changes locally, commit them, and push the code to your repo â€” not the main branch.

âœ… In my project, I used GitHub Actions as the CI tool.
When the source code is hosted in a GitHub repository, you need to create a .github/workflows folder. Inside that folder, added a YAML file (with any name), which tells GitHub Actions what tasks to run.
In the YAML file, under the jobs section, you define tasks like checkout, build, and test and steps within each task and you can mention everything under one job too
The most important part is the on section, which specifies when the workflow should be triggered â€” typically on push, pull_request, or other GitHub events.

And under Actions tab a pipeline is shown and also if it fails rerun option for failed jobs is available.

In this project, I have created a CI pipeline for a microservice that builds the code, runs unit tests, builds a Docker image, 
pushes it to Docker Hub, and updates the Kubernetes manifest with the newly created image.

And as mentioned the CI workflow is in .github/workflows folder for reference.

Challenges Faced:
In this project, I encountered issues with the CI pipeline, specifically during the job that updates the Kubernetes manifest with the newly created image. The pipeline, which was triggered on pull requests, continuously failed due to insufficient permissions in GitHub Actions.
To resolve this, I Configured the necessary GitHub Actions permissions,Used GitHub Secrets to securely store the Docker Hub username and token for authentication.
Added a Git token to enable the CI job to update the Kubernetes manifest stored in the Git repository.

Continuous Delivery (CD)
Continuous Delivery is the practice of making your changes available for deployment quickly and reliably. It can be implemented using tools like Ansible, shell scripts, or Python. However, in this project, I implemented CD using a GitOps tool â€” Argo CD.
Argo CD continuously watches the Git repository for changes in Kubernetes manifests. When changes are detected, it automatically syncs and deploys them to the Kubernetes cluster (in this case, an EKS cluster). This GitOps approach ensures that the Git repository is the single source of truth, making deployments automated, traceable, and consistent.
Using Argo CD in this project allowed seamless deployment of the updated Docker image to the EKS cluster whenever changes were pushed to the Git repository.
