ðŸš€ CI/CD
CI - Continuous Integration, in simpler terms, operates around the build process.
CD - Continuous Delivery, in simpler terms, operates around the deployment process.

Letâ€™s consider a scenario: a team member made changes to the program and now wants it to be reviewed by a peer. Now, letâ€™s say Raviâ€™s code has some security issues. 
If other developers collaborate, it can cause problems for them as well if they work on that repo. The team member, X, needs to build/test his code, and the reviewer also needs to do that, which is a lot of manual effort and takes time.
So, CI/CD came up here from DevOps to solve this problem. Instead of doing these tasks manually, we have CI â€” which uses tools like GitHub Actions, Jenkins â€” that run based on pull request or push events on GitHub.

The CI system:
* Checks out the code (pulls code from the repo)
* Builds the code
* Runs unit testing
* Performs static code analysis (like detecting unused variables, deprecated methods)
* Creates a Docker image
* Scans the image
* Updates Kubernetes manifests with that image
Now the team member is confident in all changes and asks the reviewer to check it, saying CI has passed, which saves time and manual effort, and increases efficiency and quality.
Then comes CD â€” which uses tools like GitOps tools or ArgoCD to deploy the application on top of Kubernetes (K8s). So, CD is the continuous delivery of all your changes.

ðŸ”„ Pull Request
A pull request is when we want your changes to be merged with the main branch and reviewed by a peer. We create a pull request by first creating a branch with your changes. 
Before that, you make changes locally, commit them, and push the code to your repo â€” not the main branch.

âœ… In my project, I used GitHub Actions as the CI tool.
When the source code is hosted in a GitHub repository, you need to create a .github/workflows folder. Inside that folder, added a YAML file (with any name), which tells GitHub Actions what tasks to run.
In the YAML file, under the jobs section, you define tasks like checkout, build, and test and steps within each task and you can mention everything under one job too
The most important part is the on section, which specifies when the workflow should be triggered â€” typically on push, pull_request, or other GitHub events.

In this project, I have created a CI pipeline for a microservice that builds the code, runs unit tests, builds a Docker image, 
pushes it to Docker Hub, and updates the Kubernetes manifest with the newly created image.

And as mentioned the CI workflow is in .github/workflows folder for reference.

Challenges faced
My update  job to k8s manifiest wioth teh new image craeted and i craeted the ci pine on pull rewuest but it was continupusly failed becuase of not
