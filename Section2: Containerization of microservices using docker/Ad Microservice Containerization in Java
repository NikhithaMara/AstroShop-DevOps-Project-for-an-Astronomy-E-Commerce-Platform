ğŸ“¦ Containerized Ad Service (Java)
This microservice, written in Java, was containerized using a multi-stage Docker build approach to produce a lightweight and production-ready Docker image.

ğŸ› ï¸ Multi-Stage Docker Build Approach
I followed a two-stage build process â€” build and release â€” to ensure that the final image contains only the necessary binaries and runtime files.

ğŸ”¨ Build Stage
* Pulled the official jdk base image from Docker Hub registry.
* Set the WORKDIR to /usr/src/app for structured and consistent builds in container.
* Copied gradle dependencies and source code into workdir and run the gradle to build java application
*

ğŸš€ Release Stage
* Started from a minimal jre base image from docker hub registry as java runtime needed for excuting the binary 
* Copied only the built binary from the build stage (using --from=builder).
* Included environmental variable i.e,container port 
* Set the container's ENTRYPOINT to execute the built binary so image has only binary and base image so minimal chance of vulnerabilities and secure

#Docker file

FROM eclipse-temurin:21-jdk AS builder
WORKDIR /usr/src/app/

COPY gradlew* settings.gradle* build.gradle .
COPY ./gradle ./gradle

RUN chmod +x ./gradlew
RUN ./gradlew
RUN ./gradlew downloadRepos

COPY . .
COPY ./pb ./proto
RUN chmod +x ./gradlew
RUN ./gradlew installDist -PprotoSourceDir=./proto

#####################################################

FROM eclipse-temurin:21-jre AS release 

WORKDIR /usr/src/app/

COPY --from=builder /usr/src/app/ ./

ENV AD_PORT 9099

ENTRYPOINT ["./build/install/opentelemetry-demo-ad/bin/Ad"]

#After creating the docker file build the docker image and run the image 
#added ubuntu user to the docker group so no need root previlage
docker build -t "image name" (any tag you want to put for the image)
docker run "imagename"
